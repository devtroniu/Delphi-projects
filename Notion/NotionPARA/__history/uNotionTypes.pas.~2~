unit uNotionTypes;
interface

uses
  System.SysUtils, System.JSON, System.Generics.Collections, System.Classes,  System.TypInfo,
  REST.Json;


type
  TNotionPage = class(;

  // a list of pages
  TNotionPages = class(TObjectDictionary<String, TNotionPage>);

  //generic page
  TNotionPage = class
  private
    FName: string;
    FLastEdited: string;
    FReferencedList: TNotionPages;
  protected
    FID: string;
    FReferenceID : string;
    function SignatureString: string; virtual;
  public
    property Name: string read FName;
    property ID: string read FID;
    property LastEdited: string read FLastEdited;
    property Reffers: string read FReferenceID;
    property ReferencedBy: TNotionPages read FReferencedList;
    constructor Create(aJSON: TJSONObject); virtual;
    function ToString: String; override;
    function ToJSON: TJSONObject; virtual;
  end;


  // a list of Notion Pages
  TNotionPagesCollection = class
  protected
    FName: string;
    FDrive: TNotionDrive;
    FPages : TNotionPages;

    function LoadPages(pagesJSON: TJSONObject): boolean;
    function GetNotionPage(obj: TJSONObject): TNotionPage; virtual;
  public
    constructor Create(aNotionDrive : TNotionDrive); virtual;

    property Name: String read FName;
    property Pages: TNotionPages read FPages;

    function ToString: string; override;
  end;


  // a list of Notion Pages, from a dataset
  TNotionDataSet = class(TNotionPagesCollection)
  private
    procedure SetDBID(id: String);
  protected
    FDbId: string;
    FPageSize: Integer;
  public
    function RetrievePages: boolean;
    procedure Initialize;
    function PageById(id: string): TNotionPage;
    function ToJSON: TJSONObject; virtual;

    property PageSize: Integer read FPageSize write FPageSize;
    property DbID: String read FDbId write SetDBID;
  end;


  TNotionDataSetType = (dstAreasResources, dstProjects, dstTasks, dstNotes, dstSomethingNew);





implementation
uses
 uPARATypes, System.Threading, System.SyncObjs, uThreadedGet;


{ TNotionPage }

constructor TNotionPage.Create(aJSON: TJSONObject);
begin
  FName := 'generic Name';
  FID := 'generic ID';
  FLastEdited := 'generic Last edited';
  FReferenceID := '';
  FReferencedList := TNotionPages.Create;
  try
    var locValue: TJSONValue := aJSON.FindValue('id');
    if (locValue <> nil) then
       FID := locValue.Value;
    locValue := aJSON.FindValue('properties.Name.title[0].plain_text');
    if (locValue <> nil) then
       FName := locValue.Value;
    locValue := aJSON.FindValue('last_edited_time');
    if (locValue <> nil) then
       FLastEdited := locValue.Value;
  finally
  end;
end;

function TNotionPage.SignatureString: string;
begin
  (*
  Result := Format('%s, "name": %s, "id": %s, "edited": %s}', [ClassName, FName, FID, FLastEdited]);
  if FReferenceID <> '' then
    Result := Result + Format(', "reffers: %s}', [FReferenceID]);
  *)
  Result := Format('%s, "name": %s}', [ClassName, FName]);
end;

function TNotionPage.ToJSON: TJSONObject;
var
  jsonArray: TJSONArray;
begin
  Result := TJSONObject.Create;
  Result.AddPair('entity', ClassName);
  Result.AddPair('name', Name);
  Result.AddPair('id', ID);
  Result.AddPair('edited', LastEdited);
  if ReferencedBy.Count > 0 then
  begin
    jsonArray := TJSONArray.Create;
    for var Key in ReferencedBy.Keys do
    begin
      jsonArray.Add(ReferencedBy[Key].ToJSON);
    end;
    Result.AddPair('pages', jsonArray);
  end;
end;

function TNotionPage.ToString: String;
var
  sl: TStringList;
begin
  //write children, if any
  if ReferencedBy.Count > 0 then
  begin
    sl := TStringList.Create;
    sl.Add(SignatureString);
    sl.Add('  == referenced by ==');
    for var Key in ReferencedBy.Keys do
      sl.Add('  ' + ReferencedBy[Key].ToString);
    Result := sl.Text;
  end
  else
    Result := SignatureString;
end;

{ TNotionPagesCollection }
// instantiate the pages list, with no ownership
constructor TNotionPagesCollection.Create(aNotionDrive : TNotionDrive);
begin
  FDrive := aNotionDrive;
  FPages := TNotionPages.Create([]);
end;

// in this type of list, we handle generic pages
function TNotionPagesCollection.GetNotionPage(obj: TJSONObject): TNotionPage;
begin
  Result := TNotionPage.Create(obj);
end;

// based on a received JSON, builds the pages in the internal data representation
function TNotionPagesCollection.LoadPages(pagesJSON: TJSONObject): Boolean;
var
  pageLoc: TNotionPage;
  pages: TJSONArray;
begin
  Result := False;

  pages := TJSONArray(pagesJSON.GetValue('results'));
  if (pages <> nil) then
  begin
    var enum: TJSONArray.TEnumerator := pages.GetEnumerator;
    while enum.MoveNext do
    begin
      var JSONObj: TJSONObject := TJSONObject(enum.Current);
      // generic type, overriden in descendats
      pageLoc := GetNotionPage(JSONObj);
      // add to local collection
      FPages.Add(pageLoc.ID, pageLoc);
    end;
    Result := True;
  end;
end;

function TNotionPagesCollection.ToString: string;
var
  sl: TStringList;
begin
  sl := TStringList.Create;
  for var Key in Pages.Keys do
     sl.Add(Pages[Key].ToString);
  Result := sl.Text;
end;

{ TNotionDataSet }

procedure TNotionDataSet.SetDBID(id: String);
begin
  // temporarely give it a name
  FName := id;
  FDBID := id;

  // if threaded, will call Initialize explicitly in a thread
  if FDrive.IsThreaded then
    Exit;

  // initialize here if not threaded
  Initialize;
end;

procedure TNotionDataSet.Initialize;
var
  locClient: TNotionClient;
begin
  if FDrive.IsThreaded then
  begin
    locClient := FDrive.Client.Clone(FName);
    locClient.LogMessage('retrive dataset info - threaded');
  end
  else
  begin
    locClient := FDrive.Client;
    locClient.LogMessage('retrive dataset info');
  end;

  // get the real name from Notion
  var jSon := locClient.DOGet(Format('databases/%s', [FDbId]), '');
  if Assigned(jSon) then
  begin
    var locValue := jSon.FindValue('title[0].text.content');
    if (locValue <> nil) then
       FName := locValue.Value;
  end;

  locClient.LogMessage(FName + ' found.');
end;


// makes a call to Notion to fetch a number of objects
// depending on the setting of FDrive, this can be called directly or
// executed from a thread
function TNotionDataSet.RetrievePages: Boolean;
var
  resource: string;
  body: string;
  response: TJSONObject;
  locClient: TNotionClient;
begin
  Result := false;

  if (FPageSize > 0) then
  begin
    body := '{"page_size": ' + FPageSize.ToString + '}';
  end;
  resource := Format('databases/%s/query', [DbId]);

  if FDrive.IsThreaded then
    // clone the NotionClient to allow individual sets of REST components + log files and avoid conflicts
    locClient := FDrive.Client.Clone(DbID)
  else
    locClient := FDrive.Client;

  // make the call
  response := locClient.DOPost(resource, body);

  if (response <> nil) then begin
    Result := LoadPages(response);
  end;

  if FDrive.IsThreaded then
    locClient.Free;
end;


function TNotionDataSet.PageById(id: string): TNotionPage;
begin
  Result := nil;
  if Pages.ContainsKey(id) then
    Result := Pages[id];
end;


function TNotionDataSet.ToJSON: TJSONObject;
var
  jsonMain: TJSONObject;
  jsonArray: TJSONArray;
begin
  jsonMain := TJSONObject.Create;
  if Pages.Count > 0 then
  begin
    jsonArray := TJSONArray.Create;
    for var Key in Pages.Keys do
    begin
      jsonArray.Add(Pages[Key].ToJSON);
    end;
    jsonMain.AddPair(ClassName, jsonArray);
  end;
  Result := jsonMain;
end;

end.
